#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# ///
"""xtm-send --- send s-expressions to a running Extempore process.

Maintains a persistent TCP connection via a background relay to avoid
per-eval connection overhead and log noise. The relay starts automatically
on first use and exits when Extempore disconnects.

Environment:
  XTM_PORT  Extempore TCP port (default: 7099)
  XTM_HOST  Extempore host (default: localhost)

Usage:
  echo "(println 42)" | xtm-send
  xtm-send --stop       kill the background relay

In Helix, select a top-level form (e.g. mam) then:
  :pipe-to xtm-send
"""

import os
import signal
import socket
import subprocess
import sys
import time

SOCK_DIR = os.environ.get("XDG_RUNTIME_DIR", "/tmp")
SOCK_PATH = os.path.join(SOCK_DIR, f"xtm-eval-{os.getuid()}.sock")
PID_PATH = SOCK_PATH + ".pid"
HOST = os.environ.get("XTM_HOST", "localhost")
PORT = int(os.environ.get("XTM_PORT", "7099"))


def relay():
    xtm = socket.create_connection((HOST, PORT), timeout=5)
    xtm.recv(1024)  # consume welcome banner

    try:
        os.unlink(SOCK_PATH)
    except FileNotFoundError:
        pass

    srv = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    srv.bind(SOCK_PATH)
    srv.listen(5)

    with open(PID_PATH, "w") as f:
        f.write(str(os.getpid()))

    def cleanup(*_):
        for s in (srv, xtm):
            try:
                s.close()
            except OSError:
                pass
        for p in (SOCK_PATH, PID_PATH):
            try:
                os.unlink(p)
            except OSError:
                pass
        sys.exit(0)

    signal.signal(signal.SIGTERM, cleanup)
    signal.signal(signal.SIGINT, cleanup)

    try:
        while True:
            conn, _ = srv.accept()
            data = b""
            while chunk := conn.recv(4096):
                data += chunk
            conn.close()
            if data:
                xtm.sendall(data.rstrip() + b"\r\n")
    except (BrokenPipeError, ConnectionResetError, OSError):
        cleanup()


def ensure_relay():
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        sock.connect(SOCK_PATH)
        sock.close()
        return
    except (FileNotFoundError, ConnectionRefusedError, OSError):
        sock.close()

    try:
        os.unlink(SOCK_PATH)
    except FileNotFoundError:
        pass

    subprocess.Popen(
        [sys.executable, __file__, "--relay"],
        stdout=subprocess.DEVNULL,
        stderr=subprocess.DEVNULL,
        start_new_session=True,
    )

    for _ in range(30):
        time.sleep(0.1)
        try:
            s = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            s.connect(SOCK_PATH)
            s.close()
            return
        except (FileNotFoundError, ConnectionRefusedError, OSError):
            continue

    print("xtm-send: failed to start relay", file=sys.stderr)
    sys.exit(1)


def send(expr: str):
    ensure_relay()
    sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
    try:
        sock.connect(SOCK_PATH)
        sock.sendall(expr.encode())
        sock.close()
    except OSError as e:
        print(f"xtm-send: {e}", file=sys.stderr)
        sys.exit(1)


def stop():
    try:
        with open(PID_PATH) as f:
            pid = int(f.read().strip())
        os.kill(pid, signal.SIGTERM)
        print("xtm-send: relay stopped")
    except FileNotFoundError:
        print("xtm-send: no relay running")
    except ProcessLookupError:
        for p in (SOCK_PATH, PID_PATH):
            try:
                os.unlink(p)
            except FileNotFoundError:
                pass
        print("xtm-send: cleaned up stale relay")


if __name__ == "__main__":
    if "--help" in sys.argv or "-h" in sys.argv:
        print((__doc__ or "").strip())
    elif "--relay" in sys.argv:
        relay()
    elif "--stop" in sys.argv:
        stop()
    else:
        expr = sys.stdin.read()
        if expr.strip():
            send(expr)
