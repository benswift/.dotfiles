#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = ["pygls>=2.0.1"]
# ///

import json
import re
import subprocess
from lsprotocol import types
from pygls.lsp.server import LanguageServer

ADDRESS_HEADER_RE = re.compile(r"^(To|Cc|Bcc|From|Reply-To)\s*:", re.IGNORECASE)


def is_address_header(line: str) -> bool:
    return ADDRESS_HEADER_RE.match(line) is not None


def extract_query(line: str, character: int) -> str | None:
    colon_idx = line.find(":")
    if colon_idx < 0 or character <= colon_idx:
        return None
    after_colon = line[colon_idx + 1 : character]
    segments = after_colon.split(",")
    return segments[-1].strip()


def parse_contacts(json_str: str | None) -> list[dict]:
    if json_str is None:
        return []
    try:
        result = json.loads(json_str)
        return result if isinstance(result, list) else []
    except (json.JSONDecodeError, TypeError):
        return []


def format_display_name(name: str | None, email: str) -> str:
    if name and name != email:
        return f"{name} <{email}>"
    return f"<{email}>"


def contacts_to_completion_items(contacts: list[dict]) -> list[types.CompletionItem]:
    items = []
    for contact in contacts:
        email = contact.get("email", "")
        name = contact.get("name")
        frequency = contact.get("frequency", 0)
        display = format_display_name(name, email)
        sort_key = f"{10_000_000 - frequency:010d}"
        items.append(
            types.CompletionItem(
                label=display,
                kind=types.CompletionItemKind.Text,
                insert_text=display,
                sort_text=sort_key,
                filter_text=f"{name or ''} {email}",
            )
        )
    return items


def run_mu_cfind(query: str, max_results: int = 50) -> str:
    if not query:
        return "[]"
    try:
        result = subprocess.run(
            ["mu", "cfind", "--format=json", f"--maxnum={max_results}", query],
            capture_output=True,
            text=True,
            timeout=5,
        )
        return result.stdout if result.returncode == 0 else "[]"
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return "[]"


def in_header_section(lines: list[str], current_line: int) -> bool:
    for i in range(current_line):
        if lines[i].strip() == "":
            return False
    return True


server = LanguageServer("mutt-compose-lsp", "v0.1.0")


@server.feature(
    types.TEXT_DOCUMENT_COMPLETION,
    types.CompletionOptions(trigger_characters=[",", " "]),
)
def completions(params: types.CompletionParams) -> types.CompletionList | None:
    doc = server.workspace.get_text_document(params.text_document.uri)
    lines = doc.source.splitlines()
    line_idx = params.position.line
    character = params.position.character

    if line_idx >= len(lines):
        return None

    if not in_header_section(lines, line_idx):
        return None

    line = lines[line_idx]
    if not is_address_header(line):
        return None

    query = extract_query(line, character)
    if query is None:
        return None

    stdout = run_mu_cfind(query)
    contacts = parse_contacts(stdout)
    items = contacts_to_completion_items(contacts)
    return types.CompletionList(is_incomplete=True, items=items)


if __name__ == "__main__":
    server.start_io()
