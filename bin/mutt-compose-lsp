#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.12"
# dependencies = ["pygls>=2.0.1"]
# ///

import json
import os
import re
import subprocess
from lsprotocol import types
from pygls.lsp.server import LanguageServer

ADDRESS_HEADER_RE = re.compile(r"^(To|Cc|Bcc|From|Reply-To)\s*:", re.IGNORECASE)
ATTACH_HEADER_RE = re.compile(r"^Attach\s*:", re.IGNORECASE)
MAX_ATTACHMENT_SIZE_MB = 10


def is_address_header(line: str) -> bool:
    return ADDRESS_HEADER_RE.match(line) is not None


def is_attach_header(line: str) -> bool:
    return ATTACH_HEADER_RE.match(line) is not None


def extract_query(line: str, character: int) -> str | None:
    colon_idx = line.find(":")
    if colon_idx < 0 or character <= colon_idx:
        return None
    after_colon = line[colon_idx + 1 : character]
    segments = after_colon.split(",")
    return segments[-1].strip()


def parse_contacts(json_str: str | None) -> list[dict]:
    if json_str is None:
        return []
    try:
        result = json.loads(json_str)
        return result if isinstance(result, list) else []
    except (json.JSONDecodeError, TypeError):
        return []


def format_display_name(name: str | None, email: str) -> str:
    if name and name != email:
        return f"{name} <{email}>"
    return f"<{email}>"


def contacts_to_completion_items(contacts: list[dict]) -> list[types.CompletionItem]:
    items = []
    for contact in contacts:
        email = contact.get("email", "")
        name = contact.get("name")
        frequency = contact.get("frequency", 0)
        display = format_display_name(name, email)
        sort_key = f"{10_000_000 - frequency:010d}"
        items.append(
            types.CompletionItem(
                label=display,
                kind=types.CompletionItemKind.Text,
                insert_text=display,
                sort_text=sort_key,
                filter_text=f"{name or ''} {email}",
            )
        )
    return items


def run_mu_cfind(query: str, max_results: int = 50) -> str:
    if not query:
        return "[]"
    try:
        result = subprocess.run(
            ["mu", "cfind", "--format=json", f"--maxnum={max_results}", query],
            capture_output=True,
            text=True,
            timeout=5,
        )
        return result.stdout if result.returncode == 0 else "[]"
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return "[]"


def run_fd_for_attach(query: str, max_results: int = 50) -> list[str]:
    if not query:
        return []
    if not (query.startswith("/") or query.startswith("~") or query.startswith(".")):
        return []
    try:
        expanded = os.path.expanduser(query)
        if os.path.isdir(expanded):
            search_dir = expanded
            pattern = "."
        else:
            search_dir = os.path.dirname(expanded) or "."
            pattern = os.path.basename(expanded) or "."
        if not os.path.isdir(search_dir):
            return []
        result = subprocess.run(
            [
                "fd",
                "-t",
                "f",
                "-S",
                f"-{MAX_ATTACHMENT_SIZE_MB}M",
                "-a",
                pattern,
                search_dir,
            ],
            capture_output=True,
            text=True,
            timeout=5,
            stderr=subprocess.DEVNULL,
        )
        files = [f for f in result.stdout.strip().split("\n") if f]
        return files[:max_results]
    except (subprocess.TimeoutExpired, FileNotFoundError):
        return []


def format_file_size(size_bytes: int) -> str:
    if size_bytes < 1024:
        return f"{size_bytes} B"
    elif size_bytes < 1024 * 1024:
        return f"{size_bytes / 1024:.1f} KB"
    else:
        return f"{size_bytes / (1024 * 1024):.1f} MB"


def files_to_completion_items(files: list[str]) -> list[types.CompletionItem]:
    items = []
    home = os.path.expanduser("~")
    for path in files:
        display = path.replace(home, "~", 1) if path.startswith(home) else path
        try:
            size = os.path.getsize(path)
            detail = format_file_size(size)
        except OSError:
            detail = None
        items.append(
            types.CompletionItem(
                label=display,
                kind=types.CompletionItemKind.File,
                insert_text=path,
                filter_text=display,
                detail=detail,
            )
        )
    return items


def in_header_section(lines: list[str], current_line: int) -> bool:
    for i in range(current_line):
        if lines[i].strip() == "":
            return False
    return True


server = LanguageServer("mutt-compose-lsp", "v0.1.0")


@server.feature(
    types.TEXT_DOCUMENT_COMPLETION,
    types.CompletionOptions(trigger_characters=[",", " ", "/"]),
)
def completions(params: types.CompletionParams) -> types.CompletionList | None:
    doc = server.workspace.get_text_document(params.text_document.uri)
    lines = doc.source.splitlines()
    line_idx = params.position.line
    character = params.position.character

    if line_idx >= len(lines):
        return None

    if not in_header_section(lines, line_idx):
        return None

    line = lines[line_idx]

    if is_attach_header(line):
        query = extract_query(line, character)
        if query is None:
            return None
        files = run_fd_for_attach(query)
        items = files_to_completion_items(files)
        return types.CompletionList(is_incomplete=True, items=items)

    if is_address_header(line):
        query = extract_query(line, character)
        if query is None:
            return None
        stdout = run_mu_cfind(query)
        contacts = parse_contacts(stdout)
        items = contacts_to_completion_items(contacts)
        return types.CompletionList(is_incomplete=True, items=items)

    return None


if __name__ == "__main__":
    server.start_io()
