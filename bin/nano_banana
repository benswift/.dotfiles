#!/usr/bin/env -S uv run --script
# /// script
# requires-python = ">=3.11,<3.14"
# dependencies = ["replicate", "httpx", "typer"]
# ///
"""Generate an image using Google's Nano Banana Pro model via Replicate API.

Environment:
    REPLICATE_API_KEY: Your Replicate API token (required)

Provide a single prompt. Optionally include one or more input images with
--input-image (repeatable) to transform or use as reference (model supports up
to 14). Use --preset to include predefined reference images from a preset.

Generated images will be saved to:
    <output-dir>/<iso-timestamp>/<slugified-image-prompt>.avif

By default, images are converted to AVIF for better compression. Use --jpg to
keep the original JPG format.
"""

import datetime
import os
import re
import subprocess
import sys
from pathlib import Path
from typing import Annotated, NoReturn

import httpx
import replicate
import typer
from replicate.exceptions import ReplicateError

MODEL_ID = "google/nano-banana-pro"
PRESETS_DIR = Path(__file__).parent / "nano_banana_presets"

app = typer.Typer()


def get_preset_images(preset_name: str) -> list[Path]:
    """Get all image files from a preset directory.

    Args:
        preset_name: Name of the preset (subdirectory of presets dir)

    Returns:
        List of image paths sorted alphabetically

    Raises:
        FileNotFoundError: If preset directory doesn't exist
    """
    preset_dir = PRESETS_DIR / preset_name
    if not preset_dir.is_dir():
        available = [d.name for d in PRESETS_DIR.iterdir() if d.is_dir()]
        raise FileNotFoundError(
            f"Preset '{preset_name}' not found. Available: {', '.join(available) or 'none'}"
        )
    image_extensions = {".jpg", ".jpeg", ".png", ".webp"}
    images = [
        p for p in preset_dir.iterdir() if p.suffix.lower() in image_extensions
    ]
    return sorted(images)


def error_exit(message: str) -> NoReturn:
    """Print error message and exit with status 1."""
    print(f"Error: {message}", file=sys.stderr)
    sys.exit(1)


def get_api_token() -> str:
    """Get Replicate API token from environment.

    Returns:
        API token string

    Raises:
        KeyError: If REPLICATE_API_KEY is not set
    """
    try:
        return os.environ["REPLICATE_API_KEY"]
    except KeyError:
        raise KeyError(
            "REPLICATE_API_KEY environment variable not set. "
            "Get your token at https://replicate.com/account/api-tokens"
        )


def slugify(text: str, max_words: int = 6) -> str:
    """Convert text to slug, taking only first max_words words.

    Args:
        text: Text to slugify
        max_words: Maximum number of words to include (default: 6)

    Returns:
        Slugified string (e.g., "Hello World Example" -> "hello-world-example")
    """
    # Convert to lowercase and split into words
    words = text.lower().split()

    # Take first max_words
    words = words[:max_words]

    # Join and clean: keep only alphanumeric and hyphens
    slug = "-".join(words)
    slug = re.sub(r"[^a-z0-9-]", "-", slug)

    # Remove multiple consecutive hyphens and strip leading/trailing hyphens
    slug = re.sub(r"-+", "-", slug)
    slug = slug.strip("-")

    return slug if slug else "untitled"


def download_image(url: str, output_path: Path) -> None:
    """Download image from URL and save to file.

    Args:
        url: URL to download from
        output_path: Path where the image should be saved

    Raises:
        httpx.HTTPError: If download fails
        OSError: If file cannot be written
    """
    response = httpx.get(url, timeout=60.0, follow_redirects=True)
    response.raise_for_status()
    output_path.write_bytes(response.content)


AVIF_QUALITY = 60


def convert_to_avif(jpg_path: Path, avif_path: Path) -> None:
    """Convert JPG to AVIF and delete the original.

    Args:
        jpg_path: Path to the source JPG file
        avif_path: Path where the AVIF should be saved

    Raises:
        subprocess.CalledProcessError: If avifenc fails
        FileNotFoundError: If avifenc is not installed
    """
    subprocess.run(
        ["avifenc", "-q", str(AVIF_QUALITY), str(jpg_path), str(avif_path)],
        check=True,
        capture_output=True,
    )
    jpg_path.unlink()


def generate_image(
    prompt: str,
    output_path: Path,
    client: replicate.Client,
    aspect_ratio: str,
    resolution: str,
    output_format: str,
    safety_filter_level: str,
    input_image_paths: list[Path] | None = None,
) -> None:
    """Generate image using Nano Banana Pro via Replicate API."""
    model_input: dict[str, str | list] = {
        "prompt": prompt,
        "output_format": output_format,
        "aspect_ratio": aspect_ratio,
        "resolution": resolution,
        "safety_filter_level": safety_filter_level,
    }

    if input_image_paths:
        from contextlib import ExitStack

        with ExitStack() as stack:
            image_files = [
                stack.enter_context(open(path, "rb")) for path in input_image_paths
            ]
            model_input["image_input"] = image_files
            output = client.run(MODEL_ID, input=model_input)
    else:
        output = client.run(MODEL_ID, input=model_input)

    if not output:
        raise ValueError("Model returned empty output")

    image_url = str(output)
    download_image(image_url, output_path)


@app.command()
def _main_impl(
    prompt: Annotated[str, typer.Argument(help="Image prompt")],
    output_dir: Annotated[Path, typer.Option(help="Output directory")] = Path(
        "nano_banana_output"
    ),
    input_image: Annotated[
        list[Path],
        typer.Option(
            "--input-image",
            help="Optional input image(s) to transform or use as reference (repeat to supply multiple)",
            exists=True,
            dir_okay=False,
        ),
    ] = [],
    preset: Annotated[
        str | None,
        typer.Option(
            help="Load reference images from a preset (images added before --input-image)"
        ),
    ] = None,
    aspect_ratio: Annotated[
        str,
        typer.Option(help="Aspect ratio for generated images"),
    ] = "16:9",
    resolution: Annotated[
        str,
        typer.Option(help="Resolution: 1K, 2K, or 4K"),
    ] = "2K",
    jpg: Annotated[
        bool,
        typer.Option("--jpg", help="Keep original JPG instead of converting to AVIF"),
    ] = False,
    output_filename: Annotated[
        str | None,
        typer.Option(
            help="Output filename (without extension, defaults to slugified prompt)"
        ),
    ] = None,
    safety_filter_level: Annotated[
        str,
        typer.Option(
            help=(
                "Safety filter setting "
                "(block_low_and_above, block_medium_and_above, block_only_high)"
            )
        ),
    ] = "block_only_high",
) -> None:
    """Generate a single image using Google's Nano Banana Pro model via Replicate API.

    Examples:

      nano_banana "sunrise over a misty valley" --resolution 2K --aspect-ratio 4:3

      nano_banana "studio portrait" --input-image headshot.jpg --resolution 1K --jpg
    """
    all_input_images: list[Path] = []
    if preset:
        all_input_images.extend(get_preset_images(preset))
    all_input_images.extend(input_image)

    api_token = get_api_token()

    # Create output directory structure
    # If output_filename is specified, use output_dir directly; otherwise create timestamped subdir
    if output_filename:
        target_dir = output_dir
    else:
        timestamp = datetime.datetime.now(datetime.timezone.utc).strftime(
            "%Y-%m-%dT%H-%M-%SZ"
        )
        target_dir = output_dir / timestamp
    target_dir.mkdir(parents=True, exist_ok=True)

    # Create Replicate client once
    client = replicate.Client(api_token=api_token)

    output_format = "jpg" if jpg else "avif"
    filename = output_filename if output_filename else slugify(prompt)

    print(f"Model: {MODEL_ID}")
    print(f"Aspect ratio: {aspect_ratio}")
    print(f"Resolution: {resolution}")
    print(f"Format: {output_format}")
    print(f"Safety filter: {safety_filter_level}")
    if preset:
        print(f"Preset: {preset}")
    if all_input_images:
        print(f"Input images: {', '.join(str(p) for p in all_input_images)}")
    print(f"Output directory: {target_dir}")
    print("Generating 1 image...")
    print()

    jpg_path = target_dir / f"{filename}.jpg"
    final_path = target_dir / f"{filename}.{output_format}"

    print(f"Prompt: {prompt}")
    print(f"Output: {final_path}")

    generate_image(
        prompt,
        jpg_path,
        client,
        aspect_ratio,
        resolution,
        "jpg",
        safety_filter_level,
        all_input_images if all_input_images else None,
    )

    if not jpg:
        print("Converting to AVIF...")
        convert_to_avif(jpg_path, final_path)

    print()
    print("Image generated successfully")


if __name__ == "__main__":
    try:
        app()
    except KeyboardInterrupt:
        print("\nInterrupted by user", file=sys.stderr)
        sys.exit(130)
    except KeyError as e:
        error_exit(str(e))
    except ValueError as e:
        error_exit(str(e))
    except FileNotFoundError as e:
        if "avifenc" in str(e):
            error_exit("avifenc not found. Install with: brew install libavif")
        error_exit(f"File not found: {e}")
    except subprocess.CalledProcessError as e:
        error_exit(f"AVIF conversion failed: {e.stderr.decode() if e.stderr else e}")
    except OSError as e:
        error_exit(f"File operation failed: {e}")
    except httpx.HTTPError as e:
        error_exit(f"HTTP request failed: {e}")
    except ReplicateError as e:
        error_exit(f"Replicate API error: {e}")
